{
  "name": "deferred-queue",
  "version": "0.5.1",
  "description": "Series control flow library",
  "keywords": [
    "asynchronous",
    "deferred",
    "queue",
    "flow",
    "task"
  ],
  "author": {
    "name": "Gabriel Llamas",
    "email": "gagle@outlook.com"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/gagle/node-deferred-queue.git"
  },
  "engines": {
    "node": ">=0.10"
  },
  "devDependencies": {
    "async": "0.2.x",
    "bluebird": "0.8.x",
    "q": "0.9.x",
    "speedy": "*",
    "step": "0.0.x"
  },
  "scripts": {
    "test": "node test/index"
  },
  "license": "MIT",
  "main": "lib",
  "readme": "deferred-queue\r\n==============\r\n\r\n#### Series control flow library ####\r\n\r\n[![NPM version](https://badge.fury.io/js/deferred-queue.png)](http://badge.fury.io/js/deferred-queue \"Fury Version Badge\")\r\n[![Build Status](https://secure.travis-ci.org/gagle/node-deferred-queue.png)](http://travis-ci.org/gagle/node-deferred-queue \"Travis CI Badge\")\r\n\r\n[![NPM installation](https://nodei.co/npm/deferred-queue.png?mini=true)](https://nodei.co/npm/deferred-queue \"NodeICO Badge\")\r\n\r\nThis module brings to you a very lighweight control flow mechanism that it's meant to be the glue between the user calls and the asynchronous nature of your module. It provides a fluent interface, so if your module has an asynchronous API which tends to create the callback pyramid of doom, a deferred queue may help you. It can be also used as a standalone module.\r\n\r\nFor example, suppose you have an API like the following one:\r\n\r\n```javascript\r\nvar r = new Reader (\"file\");\r\n\r\nr.read (10, function (error, bytesRead, buffer){\r\n  if (error) return console.error (error);\r\n  fn1 (bytesRead, buffer);\r\n  \r\n  r.read (20, function (error, bytesRead, buffer){\r\n    if (error) return console.error (error);\r\n    fn2 (bytesRead, buffer);\r\n    \r\n    r.close (function (error){\r\n      if (error) return console.error (error);\r\n      fn3 ();\r\n    });\r\n  });\r\n});\r\n```\r\n\r\nThe above example has two problems: the callback nesting and the error handling. With a deferred queue the example can be rewritten as follows:\r\n\r\n```javascript\r\nvar r = new Reader (\"file\");\r\n\r\nr.on (\"error\", function (error){\r\n\tconsole.error (error);\r\n});\r\nr.on (\"close\", fn3);\r\nr.read (10, fn1);\r\nr.read (20, fn2);\r\nr.close ();\r\n```\r\n\r\nLook at the [reader](https://github.com/gagle/node-deferred-queue/blob/master/examples/reader.js) example for further details.\r\n\r\n__Projects using this library:__\r\n\r\n- [binary-reader](https://github.com/gagle/node-binary-reader): A real project based on the previous example.\r\n- [seraphim](https://github.com/gagle/node-seraphim): Configuration loading made easy.\r\n\r\n#### Documentation ####\r\n\r\n- [async vs deferred-queue](#async-dq)\r\n\r\n#### Functions ####\r\n\r\n- [_module_() : DeferredQueue](#create)\r\n\r\n#### Objects ####\r\n\r\n- [DeferredQueue](#deferredqueue)\r\n\r\n---\r\n\r\n<a name=\"async-dq\"></a>\r\n__async vs deferred-queue__\r\n\r\n`async.waterfall()` is the function with more similarities with a deferred queue.\r\n\r\n```javascript\r\nasync.waterfall ([\r\n  //Task 1\r\n  function (cb){\r\n    cb (null, 1, 2);\r\n  },\r\n  //Task 2\r\n  function (n1, n2, cb){\r\n    //n1 is 1, n2 is 2\r\n    cb ();\r\n  }\r\n], function (error){\r\n  if (error) return console.error (error);\r\n});\r\n```\r\n\r\n```javascript\r\ndq ()\r\n    .on (\"error\", function (error){\r\n      console.error (error);\r\n    })\r\n    //Task 1\r\n    .push (function (cb){\r\n      cb (null, 1, 2);\r\n    }, function (error, n1, n2){\r\n      //n1 is 1, n2 is 2\r\n    })\r\n    //Task 2\r\n    .push (function (){});\r\n```\r\n\r\nBoth are very similar but there are 3 big differences:\r\n\r\n- `async`'s error handling has a major flaw. When something fails you don't know from which task comes the error, so you cannot apply rollback or fallback strategies.\r\n\r\n  This library separates a task from its result. If you look at the task 1 you can see that [push()](#push) receives a second function as a parameter, it's the result of the task and is executed between two tasks: the current and the next. If the current task fails, the error is passed to this function and then the `error` event is emitted (if [preventDefault()]() is not called).\r\n\r\n- `async.waterfall()` forwards the result values to the next task. That's ok until you need to use these values from any other task. Javascript has closures, let's use them. There's no need to pass the values to the next task, simply store them in a closure (the second parameter of [push()](#push)) and let the user decide where to save them.\r\n\r\n    ```javascript\r\n    var myValue;\r\n    \r\n    dq ()\r\n        .on (\"error\", function (error){\r\n          console.error (error);\r\n        })\r\n        .push (function (cb){\r\n          cb (null, 1);\r\n        }, function (error, n){\r\n          if (error) return;\r\n          myValue = n;\r\n        })\r\n        .push (function (){})\r\n        .push (function (){\r\n          //Use myValue\r\n        });\r\n    ```\r\n\r\n- `async` internally uses `process.nextTick()` to call the next task. On the other hand, `deferred-queue` doesn't make any assumption, you decide how to enqueue the tasks; synchronously, asynchronously or both.\r\n\r\n    ```javascript\r\n    dq ()\r\n        .on (\"error\", function (error){\r\n          console.error (error);\r\n        })\r\n        //Synchronous\r\n        .push (function (){})\r\n        //Asynchronous\r\n        .push (function (cb){\r\n          process.nextTick (cb);\r\n        })\r\n        //Fake asynchronous (synchronous)\r\n        .push (function (cb){\r\n          cb ();\r\n        });\r\n    ```\r\n\r\n---\r\n\r\n<a name=\"create\"></a>\r\n___module_() : DeferredQueue__\r\n\r\nReturns a new [DeferredQueue](#deferredqueue) instance.\r\n\r\n```javascript\r\nvar dq = require (\"deferred-queue\");\r\nvar q = dq ();\r\n```\r\n\r\n---\r\n\r\n<a name=\"deferredqueue\"></a>\r\n__DeferredQueue__\r\n\r\n__Events__\r\n\r\n- [error](#event_error)\r\n\r\n__Methods__\r\n\r\n- [DeferredQueue#pause() : undefined](#pause)\r\n- [DeferredQueue#pending() : Number](#pending)\r\n- [DeferredQueue#preventDefault() : undefined](#preventDefault)\r\n- [DeferredQueue#push(task[, result]) : DeferredQueue](#push)\r\n- [DeferredQueue#resume() : undefined](#resume)\r\n- [DeferredQueue#unshift(task[, result]) : DeferredQueue](#unshift)\r\n\r\n<a name=\"event_error\"></a>\r\n__Error__\r\n\r\nArguments: `error`.\r\n\r\nEmitted when an error occurs.\r\n\r\n---\r\n\r\n<a name=\"pause\"></a>\r\n__DeferredQueue#pause() : undefined__\r\n\r\nPauses the queue execution. Look at the [async-function-between-tasks.js](https://github.com/gagle/node-deferred-queue/blob/master/examples/async-function-between-tasks.js) example for further details.\r\n\r\n```javascript\r\nq\r\n    .push (function (){\r\n    \t//Task\r\n    }, function (){\r\n    \t//Callback\r\n    \tthis.pause ();\r\n    })\r\n    .push (function (){\r\n    \t//This task is not executed until you call to \"resume()\"\r\n    });\r\n```\r\n\r\n---\r\n\r\n<a name=\"pending\"></a>\r\n__DeferredQueue#pending() : Number__\r\n\r\nReturns the number of pending tasks in the queue.\r\n\r\n---\r\n\r\n<a name=\"preventDefault\"></a>\r\n__DeferredQueue#preventDefault() : undefined__\r\n\r\nPrevents the propagation of the error, that is, the `error` event is not emitted. It must be used from inside the callback parameter of the [push()](#push) and [unshift()](#unshift) functions.\r\n\r\n```javascript\r\nq.push (function (){\r\n\t//Task\r\n\tthrow new Error ();\r\n}, function (error){\r\n\t//Callback\r\n\tif (error){\r\n\t\tthis.preventDefault ();\r\n\t}\r\n});\r\n```\r\n\r\n---\r\n\r\n<a name=\"push\"></a>\r\n__DeferredQueue#push(task[, result]) : DeferredQueue__\r\n\r\nAdds a task to the end of the queue and tries to execute it. If there are pending tasks, it simply waits until all the previous tasks have been executed. Think about it like a queue that is permanently executing tasks. Whenever you add a task it can be immediately executed because the queue is empty or enqueued if there are pending tasks that need to be executed first.\r\n\r\nThe `task` is the function that you want to execute. The `result` is a callback that is executed when the task finishes.\r\n\r\nThe tasks can be synchronous or asynchronous.\r\n\r\n__Synchronous__\r\n\r\nYou can only return one value. If you want to return an error, throw it, it will be catched. Both the error and the value are passed to the result callback, if any.\r\n\r\n```javascript\r\nq.push (function (){\r\n  return 1;\r\n}, function (error, value){\r\n  //error is null\r\n  //value is 1\r\n});\r\n```\r\n```javascript\r\nq.push (function (){\r\n  throw 1;\r\n}, function (error, value){\r\n  //error is 1\r\n  //value is undefined\r\n});\r\n```\r\n\r\n__Asynchronous__\r\n\r\nIf you want to execute an asynchronous task, you must call the `cb` parameter when you are ready to continue. As usual, the error is the first parameter.\r\n\r\n```javascript\r\nq.push (function (cb){\r\n  process.nextTick (function (){\r\n    cb (null, 1, 2);\r\n  });\r\n}, function (error, v1, v2){\r\n  //error is null\r\n  //v1 is 1\r\n  //v2 is 2\r\n});\r\n```\r\n```javascript\r\nq.push (function (cb){\r\n  cb (1);\r\n}, function (error, v1, v2){\r\n  //error is 1\r\n  //v1 and v2 are undefined\r\n});\r\n```\r\n\r\nNote: Being synchronous or asynchronous depends exclusively on the user, but if you use the `cb` parameter, a different internal strategy is used. In other words, you can execute a synchronous task using the `cb` parameter. This is useful when you need to return more than one value.\r\n\r\nThere are subtle differences when the tasks are synchronous or asynchronous:\r\n\r\n```javascript\r\nq.push (A);\r\nq.push (function (){\r\n  q.push (C);\r\n  q.push (D);\r\n});\r\nq.push (B);\r\n```\r\n\r\nIf A, B, C, D are asynchronous: A → B → C → D. [Asynchronous](https://github.com/gagle/node-deferred-queue/blob/master/examples/asynchronous.js) example.  \r\nIf A, B, C, D are synchronous: A → C → D → B. [Synchronous](https://github.com/gagle/node-deferred-queue/blob/master/examples/synchronous.js) example.  \r\n\r\nWhen an error occurs, it is passed to the callback and then, it is emitted. If you don't want to emit the error, call to [preventDefault()](#preventdefault):\r\n\r\n```javascript\r\nq\r\n    .on (\"error\", function (error){\r\n      //This function is not executed\r\n    })\r\n    .push (function (){\r\n      throw new Error ();\r\n    }, function (error){\r\n      if (error) this.preventDefault ();\r\n    });\r\n```\r\n\r\n__I want to execute an asynchronous function inside the result callback__\r\n\r\nYou can. Pause the queue and when you are ready to continue, resume it. Look at the [async-function-between-tasks.js](https://github.com/gagle/node-deferred-queue/blob/master/examples/async-function-between-tasks.js) example for further details.\r\n\r\n---\r\n\r\n<a name=\"resume\"></a>\r\n__DeferredQueue#resume() : undefined__\r\n\r\nResumes the queue execution. Look at the [async-function-between-tasks.js](https://github.com/gagle/node-deferred-queue/blob/master/examples/async-function-between-tasks.js) example for further details.\r\n\r\n---\r\n\r\n<a name=\"unshift\"></a>\r\n__DeferredQueue#unshift(task[, result]) : DeferredQueue__\r\n\r\nAdds a task to the beginning of the queue. It has the same functionality as the [push()](#push) function.",
  "readmeFilename": "README.md",
  "_id": "deferred-queue@0.5.1",
  "dist": {
    "shasum": "cdeb9db53796b3f5225b214ec5162f007439a4c2"
  },
  "_from": "deferred-queue@0.5.x",
  "_resolved": "https://registry.npmjs.org/deferred-queue/-/deferred-queue-0.5.1.tgz"
}
