{
  "name": "binary-reader",
  "version": "0.1.2",
  "description": "Buffered binary reader with a fluent api",
  "keywords": [
    "buffer",
    "reader",
    "binary",
    "file",
    "seek"
  ],
  "author": {
    "name": "Gabriel Llamas",
    "email": "gagle@outlook.com"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/gagle/node-binary-reader.git"
  },
  "engines": {
    "node": ">=0.10"
  },
  "dependencies": {
    "deferred-queue": "0.5.x"
  },
  "devDependencies": {
    "hex": "*"
  },
  "scripts": {
    "test": "node test/index"
  },
  "license": "MIT",
  "main": "lib",
  "readme": "binary-reader\r\n=============\r\n\r\n#### Buffered binary reader with a fluent api ####\r\n\r\n[![NPM version](https://badge.fury.io/js/binary-reader.png)](http://badge.fury.io/js/binary-reader \"Fury Version Badge\")\r\n[![Build Status](https://secure.travis-ci.org/gagle/node-binary-reader.png)](http://travis-ci.org/gagle/node-binary-reader \"Travis CI Badge\")\r\n[![Dependency Status](https://david-dm.org/gagle/node-binary-reader.png)](https://david-dm.org/gagle/node-binary-reader \"David Dependency Manager Badge\")\r\n\r\n[![NPM installation](https://nodei.co/npm/binary-reader.png?mini=true)](https://nodei.co/npm/binary-reader \"NodeICO Badge\")\r\n\r\nThis module is a wrapper around the `fs.read()` function. It has an internal buffer that maintains the last chunk of bytes read from disk, so it minimizes the number of I/O calls. If the requested bytes are already in the buffer it doesn't perform any I/O call and the bytes are copied directly from the internal buffer. It also implements a fluent interface for your ease, so it also tries to minimize the number of nested asynchronous calls.\r\n\r\n#### Documentation ####\r\n\r\n- [What are its uses?](#uses)\r\n- [How it works?](#diagrams)\r\n\r\n#### Functions ####\r\n\r\n- [_module_.open(path[, options]) : Reader](#open)\r\n\r\n#### Objects ####\r\n\r\n- [Reader](#Reader)\r\n\r\n---\r\n\r\n<a name=\"uses\"></a>\r\n__What are its uses?__\r\n\r\nAnything that needs to read big binary files to extract just a little portion of data, e.g. metadata readers: music, images, fonts, etc.\r\n\r\nBenefits:\r\n\r\n- Read big binary files without caring about how to retrieve the data and without implementing your own internal cursor system.\r\n- Avoid the callback nesting. It uses a very lightweight and fast asynchronous series control flow library: [deferred-queue](https://github.com/gagle/node-deferred-queue).\r\n- Ease the error handling.\r\n- It is lazy! It delays the open and read calls until they are necessary, i.e. `br.open(file).seek(50).close()` does nothing.\r\n\r\n---\r\n\r\n<a name=\"diagrams\"></a>\r\n__How it works?__\r\n\r\nTo make the things easier there are 5 cases depending on the buffer position and the range of the bytes that you want to read. These cases are only applicable if the buffer size is smaller than the file size, otherwise the whole file is read into memory, so only one I/O call is done.\r\n\r\nSuppose a buffer size of 5 bytes (green background).  \r\nThe pointer `p` is the cursor and it points to the first byte to read.  \r\nThe pointer `e` is the end and it points to the last byte to read.  \r\nThe `x` bytes are not in memory. They need to be read from disk.  \r\nThe `y` bytes are already in memory. No need to read them again.\r\n\r\nFor the sake of simplicity, assume that the `x` group of bytes has a length smaller than the buffer size. The binary reader takes care of this and makes all the necessary calls to read all the bytes.\r\n\r\n<p align=\"center\">\r\n  <img src=\"https://github.com/gagle/node-binary-reader/blob/master/diagram.png?raw=true\"/>\r\n</p>\r\n\r\n---\r\n\r\n<a name=\"open\"></a>\r\n___module_.open(path[, options]) : Reader__\r\n\r\nReturns a new `Reader`. The reader is lazy so the file will be opened with the first [read()](#reader_read) call. \r\n\r\nOptions:\r\n\r\n- __highWaterMark__ - _Number_  \r\n\tThe buffer size. Default is 16KB.\r\n\r\n---\r\n\r\n<a name=\"Reader\"></a>\r\n__Reader__\r\n\r\nThe reader uses a fluent interface. The way to go is to chain the operations synchronously and, after all, close the file. They will be executed in series and asynchronously. If any error occurs, an `error` event is fired, the pending tasks are cancelled and the file is automatically closed.\r\n\r\nThe `read()` and `seek()` functions receive a callback. This callback is executed when the current operation finishes and before the next one. If you need to stop executing the subsequent tasks because you've got an error or by any other reason, you must call to [cancel()](#reader_cancel). You cannot call to [close()](reader_close) because the task will be enqueued and what you need is to close the file immediately. For example:\r\n\r\n```javascript\r\nbr.open (file)\r\n    .on (\"error\", function (error){\r\n      console.error (error);\r\n    })\r\n    .on (\"close\", function (){\r\n      ...\r\n    })\r\n    .read (1, function (bytesRead, buffer){\r\n      //The subsequent tasks are not executed\r\n      this.cancel ();\r\n    })\r\n    .read (1, function (){\r\n      //This is never executed\r\n    })\r\n    .close ();\r\n```\r\n\r\n__Events__\r\n\r\n- [close](#event_close)\r\n- [error](#event_error)\r\n\r\n__Methods__\r\n\r\n- [Reader#cancel([error]) : undefined](#reader_cancel)\r\n- [Reader#close() : Reader](#reader_close)\r\n- [Reader#isEOF() : Boolean](#reader_iseof)\r\n- [Reader#read(bytes, callback) : Reader](#reader_read)\r\n- [Reader#seek(position[, whence][, callback]) : Reader](#reader_seek)\r\n- [Reader#size() : Number](#reader_size)\r\n- [Reader#tell() : Number](#reader_tell)\r\n\r\n---\r\n\r\n<a name=\"event_close\"></a>\r\n__close__\r\n\r\nArguments: none.\r\n\r\nEmitted when the reader is closed or cancelled.\r\n\r\n<a name=\"event_error\"></a>\r\n__error__\r\n\r\nArguments: `error`.\r\n\r\nEmitted when an error occurs.\r\n\r\n---\r\n\r\n<a name=\"reader_cancel\"></a>\r\n__Reader#cancel([error]) : undefined__\r\n\r\nStops the reader immediately, that is, this operation is not deferred, it cancels all the pending tasks and the file is automatically closed. If you pass an error, it will be forwarded to the `error` event instead of the emitting a `close` event.\r\n\r\nThis function is mostly used when you need to execute some arbitrary code, you get an error and therefore you need to close the reader.\r\n\r\n```javascript\r\nbr.open (file)\r\n\t\t.on (\"error\", function (error){\r\n\t\t\tconsole.error (error);\r\n\t\t})\r\n\t\t.on (\"close\", function (){\r\n\t\t\t...\r\n\t\t})\r\n\t\t.read (1, function (bytesRead, buffer, cb){\r\n\t\t  var me = this;\r\n      asyncFn (function (error){\r\n        if (error){\r\n          //The error is forwarded to the \"error\" event\r\n          //No \"close\" event is emitted if you pass an error\r\n          me.cancel (error);\r\n        }else{\r\n          //Proceed with the next task\r\n          cb ();\r\n        }\r\n      });\r\n\t\t})\r\n\t\t.read (1, function (){\r\n\t\t\t...\r\n\t\t})\r\n\t\t.close ();\r\n```\r\n\r\n---\r\n\r\n<a name=\"reader_close\"></a>\r\n__Reader#close() : Reader__\r\n\r\nCloses the reader.\r\n\r\nThis operation is deferred, it's enqueued in the list of pending tasks.\r\n\r\nIn the following example, the close operation is executed after the read operation, so the reader reads 1 byte and then closes the file.\r\n\r\n```javascript\r\nbr.open (file)\r\n    .on (\"error\", function (error){\r\n      console.error (error);\r\n    })\r\n    .on (\"close\", function (){\r\n      ...\r\n    })\r\n    .read (1, function (){ ... })\r\n    .close ();\r\n```\r\n\r\n---\r\n\r\n<a name=\"reader_iseof\"></a>\r\n__Reader#isEOF() : Boolean__\r\n\r\nChecks whether the internal cursor has reached the end of the file. Subsequent reads return an empty buffer. This operation is not deferred, it's executed immediately.\r\n\r\nIn this example the cursor is moved to the last byte but it's still not at the end, it will be after the read.\r\n\r\n```javascript\r\nvar r = br.open (file)\r\n    .on (\"error\", function (error){\r\n      console.error (error);\r\n    })\r\n    .on (\"close\", function (){\r\n      ...\r\n    })\r\n    .seek (0, { end: true }, function (){\r\n      console.log (r.isEOF ()); //false\r\n    })\r\n    .read (1, function (){\r\n      console.log (r.isEOF ()); //true\r\n    })\r\n    .close ();\r\n```\r\n\r\n---\r\n\r\n<a name=\"reader_read\"></a>\r\n__Reader#read(bytes, callback) : Reader__\r\n\r\nReads data and the cursor is automatically moved forwards. The callback receives three arguments: the number of bytes that has been read, the buffer with the raw data and a callback that's used to allow asynchronous operations between tasks. The buffer is not a view, it's a new instance, so you can modify the content without altering the internal buffer.\r\n\r\nThis operation is deferred, it's enqueued in the list of pending tasks.\r\n\r\nFor example:\r\n\r\n```javascript\r\nbr.open (file)\r\n    .on (\"error\", function (error){\r\n      console.error (error);\r\n    })\r\n    .on (\"close\", function (){\r\n      ...\r\n    }))\r\n    .read (1, function (bytesRead, buffer, cb){\r\n      //Warning! If you use the \"cb\" argument you must call it or the reader\r\n      //will hang up\r\n      process.nextTick (cb);\r\n    })\r\n    .read (1, function (){ ... })\r\n    .close ();\r\n```\r\n\r\n---\r\n\r\n<a name=\"reader_seek\"></a>\r\n__Reader#seek(position[, whence][, callback]) : Reader__\r\n\r\nMoves the cursor along the file.\r\n\r\nThis operation is deferred, it's enqueued in the list of pending tasks.\r\n\r\nThe `whence` parameter it's used to tell the reader from where it must move the cursor, it's the reference point. It has 3 options: `start`, `current`, `end`.\r\n\r\nFor example, to move the cursor from the end:\r\n\r\n```javascript\r\nseek (0, { start: true });\r\nseek (0);\r\n```\r\n\r\nBy default the cursor it's referenced from the start of the file.\r\n\r\nTo move the cursor from the current position:\r\n\r\n```javascript\r\nseek (5, { current: true });\r\nseek (-5, { current: true });\r\n```\r\n\r\nThe cursor can be moved with positive and negative offsets.\r\n\r\nTo move the cursor from the end:\r\n\r\n```javascript\r\nseek (3, { end: true });\r\n```\r\n\r\n---\r\n\r\nThis will move the cursor to the fourth byte from the end of the file.\r\n\r\n<a name=\"reader_size\"></a>\r\n__Reader#size() : Number__\r\n\r\nReturns the size of the file. This operation is not deferred, it's executed immediately.\r\n\r\n---\r\n\r\n<a name=\"reader_tell\"></a>\r\n__Reader#tell() : Number__\r\n\r\nReturns the position of the cursor. This operation is not deferred, it's executed immediately.\r\n\r\n```javascript\r\nbr.open (file)\r\n\t\t.on (\"error\", function (error){\r\n\t\t\tconsole.error (error);\r\n\t\t})\r\n\t\t.on (\"close\", function (){\r\n\t\t\t...\r\n\t\t})\r\n\t\t.seek (0, { end: true }, function (){\r\n\t\t\tconsole.log (this.tell () === this.size () - 1); //true\r\n\t\t})\r\n\t\t.read (1, function (){\r\n\t\t\tconsole.log (this.tell () === this.size ()); //true\r\n\t\t\tconsole.log (this.isEOF ()); //true\r\n\t\t})\r\n\t\t.close ();\r\n```",
  "readmeFilename": "README.md",
  "_id": "binary-reader@0.1.2",
  "dist": {
    "shasum": "f888670e5d7b04c36594159558d44e8d0a3a84dd"
  },
  "_from": "binary-reader@",
  "_resolved": "https://registry.npmjs.org/binary-reader/-/binary-reader-0.1.2.tgz"
}
